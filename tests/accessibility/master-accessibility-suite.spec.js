// tests/accessibility/master-accessibility-suite.spec.js\nimport { test, expect } from '@playwright/test';\nimport AxeBuilder from '@axe-core/playwright';\n\ntest.describe('üåü Master WCAG 2.1 AA Compliance Suite', () => {\n  \n  test.beforeEach(async ({ page }) => {\n    await page.goto('/');\n  });\n\n  test('üîç Complete WCAG 2.1 AA Audit', async ({ page }) => {\n    console.log('\\nüöÄ Starting Comprehensive WCAG 2.1 AA Accessibility Audit...');\n    \n    const report = {\n      timestamp: new Date().toISOString(),\n      url: await page.url(),\n      testResults: {},\n      summary: {}\n    };\n\n    // 1. PERCEIVABLE PRINCIPLE\n    console.log('\\nüëÅÔ∏è Testing PERCEIVABLE (Can users perceive the information?)');\n    \n    // 1.1.1 - Non-text Content\n    const images = await page.locator('img').all();\n    let imageScore = 0;\n    for (const img of images) {\n      const alt = await img.getAttribute('alt');\n      if (alt !== null) imageScore++;\n    }\n    report.testResults['1.1.1'] = {\n      criterion: 'Non-text Content',\n      passed: imageScore === images.length,\n      score: images.length > 0 ? Math.round((imageScore / images.length) * 100) : 100,\n      details: `${imageScore}/${images.length} images have alt text`\n    };\n    console.log(`  1.1.1 Non-text Content: ${report.testResults['1.1.1'].score}% (${report.testResults['1.1.1'].details})`);\n\n    // 1.3.1 - Info and Relationships (Heading Structure)\n    const h1Count = await page.locator('h1').count();\n    const headings = await page.locator('h1, h2, h3, h4, h5, h6').all();\n    const headingStructure = [];\n    \n    for (const heading of headings) {\n      const level = await heading.evaluate(el => parseInt(el.tagName.charAt(1)));\n      headingStructure.push(level);\n    }\n    \n    let headingViolations = 0;\n    for (let i = 1; i < headingStructure.length; i++) {\n      if (headingStructure[i] > headingStructure[i - 1] + 1) {\n        headingViolations++;\n      }\n    }\n    \n    report.testResults['1.3.1'] = {\n      criterion: 'Info and Relationships',\n      passed: h1Count === 1 && headingViolations === 0,\n      score: h1Count === 1 && headingViolations === 0 ? 100 : 60,\n      details: `H1 count: ${h1Count}, Heading violations: ${headingViolations}`\n    };\n    console.log(`  1.3.1 Info and Relationships: ${report.testResults['1.3.1'].score}% (${report.testResults['1.3.1'].details})`);\n\n    // 1.4.3 - Color Contrast\n    const contrastResults = await new AxeBuilder({ page })\n      .withRules(['color-contrast'])\n      .analyze();\n    \n    report.testResults['1.4.3'] = {\n      criterion: 'Contrast (Minimum)',\n      passed: contrastResults.violations.length === 0,\n      score: contrastResults.violations.length === 0 ? 100 : 50,\n      details: `${contrastResults.violations.length} contrast violations`\n    };\n    console.log(`  1.4.3 Contrast (Minimum): ${report.testResults['1.4.3'].score}% (${report.testResults['1.4.3'].details})`);\n\n    // 2. OPERABLE PRINCIPLE\n    console.log('\\n‚å®Ô∏è Testing OPERABLE (Can users operate the interface?)');\n    \n    // 2.1.1 - Keyboard Access\n    const interactiveElements = await page.locator('a[href], button, input, select, textarea').all();\n    let keyboardAccessible = 0;\n    \n    for (const element of interactiveElements.slice(0, 10)) {\n      try {\n        await element.focus();\n        const isFocused = await element.evaluate(el => document.activeElement === el);\n        if (isFocused) keyboardAccessible++;\n      } catch (error) {\n        // Element not focusable\n      }\n    }\n    \n    const testedElements = Math.min(interactiveElements.length, 10);\n    report.testResults['2.1.1'] = {\n      criterion: 'Keyboard',\n      passed: keyboardAccessible === testedElements,\n      score: testedElements > 0 ? Math.round((keyboardAccessible / testedElements) * 100) : 100,\n      details: `${keyboardAccessible}/${testedElements} elements keyboard accessible`\n    };\n    console.log(`  2.1.1 Keyboard: ${report.testResults['2.1.1'].score}% (${report.testResults['2.1.1'].details})`);\n\n    // 2.4.1 - Bypass Blocks (Skip Links)\n    const skipLinks = await page.locator('a[href^=\"#\"]').all();\n    let hasSkipLink = false;\n    \n    for (const link of skipLinks) {\n      const text = (await link.textContent())?.toLowerCase() || '';\n      const href = await link.getAttribute('href');\n      if (text.includes('skip') || href === '#main') {\n        hasSkipLink = true;\n        break;\n      }\n    }\n    \n    report.testResults['2.4.1'] = {\n      criterion: 'Bypass Blocks',\n      passed: hasSkipLink,\n      score: hasSkipLink ? 100 : 80,\n      details: hasSkipLink ? 'Skip links found' : 'No skip links detected'\n    };\n    console.log(`  2.4.1 Bypass Blocks: ${report.testResults['2.4.1'].score}% (${report.testResults['2.4.1'].details})`);\n\n    // 2.4.2 - Page Titled\n    const title = await page.title();\n    const hasGoodTitle = title && title.length > 5 && !title.toLowerCase().includes('untitled');\n    \n    report.testResults['2.4.2'] = {\n      criterion: 'Page Titled',\n      passed: hasGoodTitle,\n      score: hasGoodTitle ? 100 : 0,\n      details: `Title: \"${title}\"`\n    };\n    console.log(`  2.4.2 Page Titled: ${report.testResults['2.4.2'].score}% (${report.testResults['2.4.2'].details})`);\n\n    // 3. UNDERSTANDABLE PRINCIPLE\n    console.log('\\nüß† Testing UNDERSTANDABLE (Can users understand the information?)');\n    \n    // 3.1.1 - Language of Page\n    const htmlLang = await page.locator('html').getAttribute('lang');\n    const hasValidLang = htmlLang && htmlLang.match(/^[a-z]{2}(-[A-Z]{2})?$/);\n    \n    report.testResults['3.1.1'] = {\n      criterion: 'Language of Page',\n      passed: hasValidLang,\n      score: hasValidLang ? 100 : 0,\n      details: `Language: ${htmlLang || 'not specified'}`\n    };\n    console.log(`  3.1.1 Language of Page: ${report.testResults['3.1.1'].score}% (${report.testResults['3.1.1'].details})`);\n\n    // 3.3.2 - Labels or Instructions\n    const formElements = await page.locator('input:not([type=\"hidden\"]), select, textarea').all();\n    let labeledElements = 0;\n    \n    for (const element of formElements) {\n      const id = await element.getAttribute('id');\n      const ariaLabel = await element.getAttribute('aria-label');\n      const ariaLabelledBy = await element.getAttribute('aria-labelledby');\n      \n      let hasLabel = false;\n      \n      // Check for explicit label\n      if (id) {\n        const label = await page.locator(`label[for=\"${id}\"]`).first();\n        if (await label.count() > 0) hasLabel = true;\n      }\n      \n      // Check for ARIA labels\n      if (!hasLabel && (ariaLabel || ariaLabelledBy)) hasLabel = true;\n      \n      if (hasLabel) labeledElements++;\n    }\n    \n    report.testResults['3.3.2'] = {\n      criterion: 'Labels or Instructions',\n      passed: formElements.length === 0 || labeledElements === formElements.length,\n      score: formElements.length === 0 ? 100 : Math.round((labeledElements / formElements.length) * 100),\n      details: `${labeledElements}/${formElements.length} form elements labeled`\n    };\n    console.log(`  3.3.2 Labels or Instructions: ${report.testResults['3.3.2'].score}% (${report.testResults['3.3.2'].details})`);\n\n    // 4. ROBUST PRINCIPLE\n    console.log('\\nüèóÔ∏è Testing ROBUST (Can content be interpreted by assistive technologies?)');\n    \n    // 4.1.2 - Name, Role, Value\n    const nameRoleResults = await new AxeBuilder({ page })\n      .withRules(['button-name', 'link-name', 'input-button-name'])\n      .analyze();\n    \n    report.testResults['4.1.2'] = {\n      criterion: 'Name, Role, Value',\n      passed: nameRoleResults.violations.length === 0,\n      score: nameRoleResults.violations.length === 0 ? 100 : 75,\n      details: `${nameRoleResults.violations.length} name/role violations`\n    };\n    console.log(`  4.1.2 Name, Role, Value: ${report.testResults['4.1.2'].score}% (${report.testResults['4.1.2'].details})`);\n\n    // Calculate Overall Score\n    const allScores = Object.values(report.testResults).map(r => r.score);\n    const overallScore = Math.round(allScores.reduce((a, b) => a + b, 0) / allScores.length);\n    \n    // Generate Summary\n    const passedCount = Object.values(report.testResults).filter(r => r.passed).length;\n    const totalCount = Object.keys(report.testResults).length;\n    \n    report.summary = {\n      overallScore,\n      passedCount,\n      totalCount,\n      complianceLevel: overallScore >= 95 ? 'AAA' : overallScore >= 80 ? 'AA' : 'A',\n      status: overallScore >= 80 ? 'COMPLIANT' : 'NON-COMPLIANT'\n    };\n\n    // Display Results\n    console.log('\\nüìä === ACCESSIBILITY AUDIT RESULTS ===');\n    console.log(`Overall Score: ${overallScore}%`);\n    console.log(`WCAG Compliance Level: ${report.summary.complianceLevel}`);\n    console.log(`Status: ${report.summary.status}`);\n    console.log(`Tests Passed: ${passedCount}/${totalCount}`);\n    \n    console.log('\\nüìã Detailed Results:');\n    Object.entries(report.testResults).forEach(([key, result]) => {\n      const icon = result.passed ? '‚úÖ' : '‚ùå';\n      console.log(`${icon} ${key}: ${result.criterion} - ${result.score}%`);\n    });\n\n    if (overallScore < 100) {\n      console.log('\\nüîß Recommendations:');\n      Object.entries(report.testResults).forEach(([key, result]) => {\n        if (!result.passed) {\n          console.log(`- Fix ${key}: ${result.criterion}`);\n        }\n      });\n    }\n\n    console.log('\\nüéØ Next Steps:');\n    console.log('1. Review failed tests and implement fixes');\n    console.log('2. Re-run tests to verify improvements');\n    console.log('3. Consider AAA level enhancements');\n    console.log('4. Implement automated accessibility testing in CI/CD');\n    \n    // Test Assertions\n    expect(overallScore).toBeGreaterThanOrEqual(80); // Minimum AA compliance\n    expect(report.testResults['1.1.1'].passed).toBe(true); // Images must have alt text\n    expect(report.testResults['2.4.2'].passed).toBe(true); // Page must have title\n    expect(report.testResults['3.1.1'].passed).toBe(true); // Page must have language\n    \n    // Log full report for debugging\n    await page.evaluate((reportData) => {\n      console.log('Full Accessibility Report:', JSON.stringify(reportData, null, 2));\n    }, report);\n  });\n\n  test('üì± Mobile Accessibility Check', async ({ page }) => {\n    console.log('\\nüì± Testing Mobile Accessibility...');\n    \n    // Set mobile viewport\n    await page.setViewportSize({ width: 375, height: 667 });\n    \n    // Test touch targets\n    const buttons = await page.locator('button').all();\n    const touchIssues = [];\n    \n    for (const button of buttons.slice(0, 5)) {\n      const box = await button.boundingBox();\n      if (box && (box.width < 44 || box.height < 44)) {\n        touchIssues.push({\n          size: `${Math.round(box.width)}x${Math.round(box.height)}px`,\n          recommended: '44x44px minimum'\n        });\n      }\n    }\n    \n    console.log(`Touch Target Issues: ${touchIssues.length}`);\n    if (touchIssues.length > 0) {\n      console.log('‚ö†Ô∏è Some touch targets may be too small for mobile users');\n      touchIssues.forEach(issue => {\n        console.log(`  - ${issue.size} (should be ${issue.recommended})`);\n      });\n    }\n    \n    // Test reflow at 320px\n    await page.setViewportSize({ width: 320, height: 568 });\n    const hasHorizontalScroll = await page.evaluate(() => {\n      return document.documentElement.scrollWidth > 320;\n    });\n    \n    console.log(`Horizontal scroll at 320px: ${hasHorizontalScroll ? 'YES' : 'NO'}`);\n    \n    // This is informational, not a hard failure\n    expect(true).toBe(true);\n  });\n\n  test('üé® Color and Visual Accessibility', async ({ page }) => {\n    console.log('\\nüé® Testing Visual Accessibility...');\n    \n    // Full axe scan for visual issues\n    const axeBuilder = new AxeBuilder({ page })\n      .withTags(['wcag2a', 'wcag2aa', 'wcag21aa']);\n    \n    const results = await axeBuilder.analyze();\n    \n    console.log(`Axe Violations: ${results.violations.length}`);\n    console.log(`Axe Passes: ${results.passes.length}`);\n    \n    if (results.violations.length > 0) {\n      console.log('\\nüö® Axe Violations:');\n      results.violations.slice(0, 3).forEach((violation, index) => {\n        console.log(`${index + 1}. ${violation.id}: ${violation.description}`);\n        console.log(`   Impact: ${violation.impact}`);\n        console.log(`   Elements: ${violation.nodes.length}`);\n      });\n    }\n    \n    const complianceScore = results.passes.length / (results.passes.length + results.violations.length) * 100;\n    console.log(`Visual Compliance Score: ${Math.round(complianceScore)}%`);\n    \n    // Allow some violations but expect high compliance\n    expect(complianceScore).toBeGreaterThanOrEqual(85);\n  });\n\n  test('‚ö° Performance Impact Check', async ({ page }) => {\n    console.log('\\n‚ö° Checking Performance Impact of Accessibility Features...');\n    \n    const performance = await page.evaluate(() => {\n      const nav = performance.getEntriesByType('navigation')[0];\n      return {\n        domComplete: Math.round(nav.domComplete),\n        loadComplete: Math.round(nav.loadEventEnd),\n      };\n    });\n    \n    console.log(`DOM Complete: ${performance.domComplete}ms`);\n    console.log(`Load Complete: ${performance.loadComplete}ms`);\n    \n    // Accessibility features shouldn't significantly impact performance\n    expect(performance.domComplete).toBeLessThan(10000); // 10 seconds max\n    expect(performance.loadComplete).toBeLessThan(15000); // 15 seconds max\n    \n    console.log('‚úÖ Accessibility features have minimal performance impact');\n  });\n});